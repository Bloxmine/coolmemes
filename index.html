<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meme Magic Mirror</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: black;
            font-family: Impact, 'Arial Black', 'Helvetica Inserat', 'Bitstream Vera Sans Bold', 'Arial Bold', sans-serif;
            color: white;
            text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, -3px 0 0 #000, 3px 0 0 #000, 0 -3px 0 #000, 0 3px 0 #000;
        }
        
        #canvas-container {
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
        }
        
        #pose-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: transparent;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 1000;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .meme-text {
            font-weight: bold;
            color: white;
            margin-top: 5px;
            font-size: 28px;
            text-transform: uppercase;
        }
        
        #controls {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 0 0 15px 15px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            transition: transform 0.3s ease;
        }
        
        #controls:hover {
            transform: translateX(-50%) translateY(0);
        }
        
        .control-btn {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            padding: 0;
        }
        
        .control-btn:hover {
            background: rgb(93, 93, 93);
            transform: scale(1.1);
        }
        
        #json-file-input {
            display: none;
        }
        
        #score-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: transparent;
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            font-size: 18px;
            font-weight: bold;
        }
        
        .score-item {
            margin: 5px 0;
        }
        
        .score-value {
            color: white;
            font-weight: bold;
            font-size: 22px;
        }
        
        #achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: transparent;
            color: white;
            padding: 30px;
            border-radius: 15px;
            z-index: 2000;
            text-align: center;
            transition: transform 0.3s ease;
            box-shadow: none;
            font-size: 32px;
            font-weight: bold;
        }
        
        #achievement-popup.show {
            transform: translate(-50%, -50%) scale(1);
        }
        
        #achievement-popup h2 {
            margin: 0 0 10px 0;
            font-size: 48px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            overflow-y: auto;
        }
        
        .modal.show {
            display: block;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 50px auto;
            padding: 30px;
            max-width: 900px;
            border-radius: 15px;
            color: white;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 15px;
            font-weight: bold;
        }
        
        .modal-header h2 {
            font-size: 36px;
            text-transform: uppercase;
        }
        
        .modal-close {
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: color 0.3s;
        }
        
        .modal-close:hover {
            color: #667eea;
        }
        
        .leaderboard-entry, .achievement-item, .gallery-item {
            background: rgba(102, 126, 234, 0.2);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .achievement-item.unlocked {
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
        }
        
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .gallery-item {
            position: relative;
            aspect-ratio: 1;
            overflow: hidden;
            cursor: pointer;
        }
        
        .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .gallery-item-time {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            font-size: 11px;
        }
        
        .challenge-box {
            background: rgba(255, 107, 107, 0.2);
            border: 2px solid #ff6b6b;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }
        
        .challenge-box.active {
            border-color: #51cf66;
            background: rgba(81, 207, 102, 0.2);
        }
        
        .timer-display {
            font-size: 72px;
            font-weight: bold;
            color: white;
            text-align: center;
            margin: 20px 0;
            text-transform: uppercase;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .menu-btn {
            flex: 1;
            min-width: 120px;
        }
        
        #pose-image {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #pose-image.show {
            opacity: 0.9;
            animation: pulseFlash 0.6s ease-out;
        }
        
        @keyframes pulseFlash {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            25% {
                transform: scale(1.1);
                opacity: 1;
            }
            50% {
                transform: scale(0.95);
                opacity: 0.7;
            }
            75% {
                transform: scale(1.05);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.9;
            }
        }
        
        #cyborg-label {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            z-index: 1001;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <img id="pose-image" src="" alt="">
    
    <img id="cyborg-label" src="cyborg.svg" alt="Cyborg">
    
    <audio id="boom-sound" preload="auto">
        <source src="sounds/vine-boom.mp3" type="audio/mpeg">
    </audio>
    <div id="pose-info">
        <div>Initializing camera...</div>
        <div class="meme-text" id="meme-name"></div>
    </div>
    
    <div id="controls">
        <button class="control-btn" onclick="document.getElementById('json-file-input').click()" title="Load Poses">üìÇ</button>
        <button class="control-btn" onclick="window.open('pose-editor.html', '_blank')" title="Pose Editor">üé≠</button>
        <button class="control-btn" onclick="openLeaderboard()" title="Leaderboard">üèÜ</button>
        <button class="control-btn" onclick="openAchievements()" title="Achievements">üéñÔ∏è</button>
        <button class="control-btn" onclick="openGallery()" title="Gallery">üì∏</button>
        <button class="control-btn" onclick="openChallenges()" title="Challenges">üéØ</button>
        <button class="control-btn" onclick="toggleTimerMode()" title="Timer Mode">‚è±Ô∏è</button>
        <button class="control-btn" onclick="takeScreenshot()" title="Screenshot">üì∑</button>
        <button class="control-btn" onclick="toggleRecording()" title="Record">üé•</button>
        <input type="file" id="json-file-input" accept=".json" onchange="loadPosesFromJSON(event)">
    </div>
    
    <div id="score-panel">
        <div class="score-item">Score: <span class="score-value" id="score">0</span></div>
        <div class="score-item">Combo: <span class="score-value" id="combo">0</span>x</div>
        <div class="score-item">Poses: <span class="score-value" id="pose-count">0</span></div>
    </div>
    
    <div id="achievement-popup">
        <h2>üéñÔ∏è Achievement Unlocked!</h2>
        <p id="achievement-text"></p>
    </div>
    
    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üèÜ Leaderboard</h2>
                <span class="modal-close" onclick="closeModal('leaderboard-modal')">&times;</span>
            </div>
            <div id="leaderboard-list"></div>
        </div>
    </div>
    
    <!-- Achievements Modal -->
    <div id="achievements-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üéñÔ∏è Achievements</h2>
                <span class="modal-close" onclick="closeModal('achievements-modal')">&times;</span>
            </div>
            <div id="achievements-list"></div>
        </div>
    </div>
    
    <!-- Gallery Modal -->
    <div id="gallery-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üì∏ Photo Gallery</h2>
                <span class="modal-close" onclick="closeModal('gallery-modal')">&times;</span>
            </div>
            <div class="btn-group">
                <button class="control-btn menu-btn" onclick="clearGallery()">üóëÔ∏è Clear All</button>
                <button class="control-btn menu-btn" onclick="downloadAllPhotos()">üíæ Download All</button>
            </div>
            <div class="gallery-grid" id="gallery-grid"></div>
        </div>
    </div>
    
    <!-- Challenges Modal -->
    <div id="challenges-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üéØ Challenges</h2>
                <span class="modal-close" onclick="closeModal('challenges-modal')">&times;</span>
            </div>
            <div id="timer-mode-section" style="display:none;">
                <h3>‚è±Ô∏è Timer Challenge Active!</h3>
                <div class="timer-display" id="timer-display">0:00</div>
                <p>Hit <span id="timer-target">10</span> different poses as fast as possible!</p>
                <p>Poses remaining: <span class="score-value" id="timer-remaining">10</span></p>
                <button class="control-btn" onclick="stopTimerMode()">Stop Timer</button>
            </div>
            <div id="challenges-list"></div>
        </div>
    </div>
    
    <script>
        let video;
        let poseNet;
        let poses = [];
        let currentMeme = "default";
        let confirmedMeme = "default"; // The pose that's actually registered
        let customPoseDetection = {}; // Store custom pose detection logic
        
        // Gamification variables
        let gameScore = 0;
        let comboMultiplier = 1;
        let poseCounter = 0;
        let lastPoseType = null;
        let uniquePosesHit = new Set();
        let sessionStartTime = Date.now();
        
        // Timer mode
        let timerMode = false;
        let timerStartTime = null;
        let timerPosesRemaining = 10;
        let timerInterval = null;
        
        // Recording
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        
        // Gallery
        let photoGallery = JSON.parse(localStorage.getItem('photoGallery') || '[]');
        
        // Achievements
        let achievements = [
            { id: 'first_pose', name: 'First Steps', desc: 'Hit your first pose', unlocked: false, check: () => poseCounter >= 1 },
            { id: 'pose_master', name: 'Pose Master', desc: 'Hit 50 poses', unlocked: false, check: () => poseCounter >= 50 },
            { id: 'combo_king', name: 'Combo King', desc: 'Reach 5x combo', unlocked: false, check: () => comboMultiplier >= 5 },
            { id: 'variety_show', name: 'Variety Show', desc: 'Hit 5 different poses', unlocked: false, check: () => uniquePosesHit.size >= 5 },
            { id: 'speedster', name: 'Speedster', desc: 'Complete timer challenge under 30 seconds', unlocked: false, check: () => false },
            { id: 'photographer', name: 'Photographer', desc: 'Take 10 screenshots', unlocked: false, check: () => photoGallery.length >= 10 },
            { id: 'century_club', name: 'Century Club', desc: 'Score 100 points', unlocked: false, check: () => gameScore >= 100 },
            { id: 'marathon', name: 'Marathon Runner', desc: 'Play for 10 minutes', unlocked: false, check: () => (Date.now() - sessionStartTime) >= 600000 }
        ];
        
        // Load achievements from localStorage
        let savedAchievements = JSON.parse(localStorage.getItem('achievements') || '[]');
        savedAchievements.forEach(savedId => {
            let ach = achievements.find(a => a.id === savedId);
            if (ach) ach.unlocked = true;
        });
        
        // Leaderboard
        let leaderboard = JSON.parse(localStorage.getItem('leaderboard') || '[]');
        
        // Pose holding mechanism
        let detectedPose = "default";
        let poseHoldTime = 0;
        let lastPoseChangeTime = 0;
        const HOLD_DURATION = 1500; // 1.5 seconds in milliseconds
        const MIN_CHANGE_INTERVAL = 2000; // Minimum 2 seconds between pose changes
        
        // Sound
        const boomSound = document.getElementById('boom-sound');
        const poseImage = document.getElementById('pose-image');
        
        // Meme images - using emoji-based memes for simplicity
        let memes = {
            "arms_up": {
                name: "üéâ CELEBRATION TIME! üéâ",
                text: "Achievement Unlocked!",
                emoji: "üéä"
            },
            "t_pose": {  // 
                name: "üí™ T-POSE DOMINANCE üí™",
                text: "Assert Your Dominance",
                emoji: "üòé"
            },
            "dab": {
                name: "üëã DAB ON 'EM üëã",
                text: "Epic Dab Detected",
                emoji: "üî•"
            },
            "hands_on_hips": {
                name: "üíÅ SASSY MODE üíÅ",
                text: "Confidence Level: Maximum",
                emoji: "üíÖ"
            },
            "arms_behind_head": {
                name: "üòé CHILLIN' üòé",
                text: "Relaxed Mode Activated",
                emoji: "üßò"
            },
            "default": {
                name: "",
                text: "Strike a pose!",
                emoji: ""
            }
        };
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            video = createCapture(VIDEO);
            video.size(width, height);
            video.hide();
            
            // Initialize PoseNet
            poseNet = ml5.poseNet(video, modelReady);
            poseNet.on('pose', gotPoses);
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
        
        function modelReady() {
            console.log('PoseNet Model Loaded!');
            document.getElementById('pose-info').querySelector('div').textContent = 'Ready! Strike a pose!';
        }
        
        function gotPoses(results) {
            poses = results;
        }
        
        function draw() {
            // Calculate video scaling to cover entire canvas
            let videoAspect = video.width / video.height;
            let canvasAspect = width / height;
            let drawWidth, drawHeight, drawX, drawY;
            
            if (canvasAspect > videoAspect) {
                // Canvas is wider than video
                drawWidth = width;
                drawHeight = width / videoAspect;
                drawX = 0;
                drawY = (height - drawHeight) / 2;
            } else {
                // Canvas is taller than video
                drawHeight = height;
                drawWidth = height * videoAspect;
                drawX = (width - drawWidth) / 2;
                drawY = 0;
            }
            
            // Mirror the video
            push();
            translate(width, 0);
            scale(-1, 1);
            image(video, -drawX, drawY, drawWidth, drawHeight);
            pop();
            
            // Draw pose and detect meme
            if (poses.length > 0) {
                let pose = poses[0].pose;
                
                // Detect current pose type
                let newDetectedPose = detectPoseType(pose);
                
                // Check if pose changed
                if (newDetectedPose !== detectedPose) {
                    detectedPose = newDetectedPose;
                    poseHoldTime = millis();
                }
                
                // Check if pose has been held long enough
                let currentTime = millis();
                if (detectedPose !== confirmedMeme && 
                    currentTime - poseHoldTime >= HOLD_DURATION &&
                    currentTime - lastPoseChangeTime >= MIN_CHANGE_INTERVAL) {
                    // Pose confirmed!
                    confirmedMeme = detectedPose;
                    lastPoseChangeTime = currentTime;
                    onPoseConfirmed(confirmedMeme);
                }
                
                currentMeme = confirmedMeme;
                
                // Draw skeleton
                drawSkeleton(pose);
                
                // Draw keypoints
                drawKeypoints(pose);
                
                // Display meme overlay
                displayMeme(currentMeme);
                
                // Show hold progress if holding a new pose
                if (detectedPose !== confirmedMeme) {
                    let progress = (currentTime - poseHoldTime) / HOLD_DURATION;
                    if (progress < 1) {
                        drawHoldProgress(progress, detectedPose);
                    }
                }
            } else {
                currentMeme = confirmedMeme;
                displayMeme(currentMeme);
            }
            
            // Update info panel
            updateInfoPanel(currentMeme);
        }
        
        function onPoseConfirmed(poseName) {
            console.log('Pose confirmed:', poseName);
            
            // Play boom sound
            if (poseName !== 'default') {
                boomSound.currentTime = 0;
                boomSound.play().catch(e => console.log('Audio play failed:', e));
            }
            
            // Display pose image
            displayPoseImage(poseName);
            
            // Gamification: award points
            if (poseName !== 'default') {
                // Update combo
                if (poseName === lastPoseType) {
                    comboMultiplier = Math.min(comboMultiplier + 1, 10); // Max 10x combo
                } else {
                    comboMultiplier = 1;
                }
                
                // Award points (base 10 * combo multiplier)
                let pointsEarned = 10 * comboMultiplier;
                gameScore += pointsEarned;
                
                // Track unique poses
                uniquePosesHit.add(poseName);
                poseCounter++;
                
                // Update display
                updateScoreDisplay();
                
                // Check achievements
                checkAchievements();
                
                // Timer mode
                if (timerMode) {
                    updateTimerMode(poseName);
                }
                
                // Auto screenshot
                takeScreenshot(true); // Pass true for auto-capture
                
                lastPoseType = poseName;
            }
        }
        
        function displayPoseImage(poseName) {
            if (poseName === 'default') {
                poseImage.classList.remove('show');
                return;
            }
            
            // Get image path from meme definition
            const meme = memes[poseName];
            if (!meme || !meme.image) {
                console.log('No image defined for pose:', poseName);
                poseImage.classList.remove('show');
                return;
            }
            
            const imagePath = meme.image;
            
            // Test if image exists
            const img = new Image();
            img.onload = function() {
                poseImage.src = imagePath;
                poseImage.classList.add('show');
                
                // Hide after 3 seconds
                setTimeout(() => {
                    poseImage.classList.remove('show');
                }, 3000);
            };
            img.onerror = function() {
                console.log('Image not found:', imagePath);
                poseImage.classList.remove('show');
            };
            img.src = imagePath;
        }
        
        function drawHoldProgress(progress, poseName) {
            // Draw progress bar
            const barWidth = 200;
            const barHeight = 20;
            const x = width / 2 - barWidth / 2;
            const y = 50;
            
            // Background
            fill(0, 0, 0, 150);
            noStroke();
            rect(x - 10, y - 10, barWidth + 20, barHeight + 35, 10);
            
            // Text
            fill(255);
            textAlign(CENTER);
            textFont('Impact');
            stroke(0);
            strokeWeight(2);
            textSize(16);
            text(`HOLD POSE...`, width / 2, y + 5);
            
            // Progress bar background
            fill(50);
            noStroke();
            rect(x, y + 10, barWidth, barHeight, 5);
            
            // Progress bar fill
            fill(102, 126, 234);
            rect(x, y + 10, barWidth * progress, barHeight, 5);
            
            // Progress percentage
            fill(255);
            stroke(0);
            strokeWeight(2);
            textSize(14);
            text(Math.floor(progress * 100) + '%', width / 2, y + 25);
        }
        
        function detectPoseType(pose) {
            let leftShoulder = pose.leftShoulder;
            let rightShoulder = pose.rightShoulder;
            let leftElbow = pose.leftElbow;
            let rightElbow = pose.rightElbow;
            let leftWrist = pose.leftWrist;
            let rightWrist = pose.rightWrist;
            let leftHip = pose.leftHip;
            let rightHip = pose.rightHip;
            let nose = pose.nose;
            let leftEye = pose.leftEye;
            let rightEye = pose.rightEye;
            let leftEar = pose.leftEar;
            let rightEar = pose.rightEar;
            let leftKnee = pose.leftKnee;
            let rightKnee = pose.rightKnee;
            let leftAnkle = pose.leftAnkle;
            let rightAnkle = pose.rightAnkle;
            
            // Check custom poses first
            for (let poseId in customPoseDetection) {
                const customPose = customPoseDetection[poseId];
                if (customPose.conditions) {
                    try {
                        // Evaluate the custom condition
                        if (eval(customPose.conditions)) {
                            return poseId;
                        }
                    } catch (error) {
                        console.warn(`Error evaluating pose ${poseId}:`, error);
                    }
                }
            }
            
            // Check if key points are detected
            if (!leftShoulder || !rightShoulder || !leftWrist || !rightWrist) {
                return "default";
            }
            
            // ARMS UP (both wrists above shoulders)
            if (leftWrist.y < leftShoulder.y - 50 && 
                rightWrist.y < rightShoulder.y - 50) {
                return "arms_up";
            }
            
            // T-POSE (arms stretched out horizontally)
            if (leftWrist.y > leftShoulder.y - 50 && 
                leftWrist.y < leftShoulder.y + 50 &&
                rightWrist.y > rightShoulder.y - 50 && 
                rightWrist.y < rightShoulder.y + 50 &&
                leftWrist.x < leftShoulder.x - 100 &&
                rightWrist.x > rightShoulder.x + 100) {
                return "t_pose";
            }
            
            // DAB (one arm up, one arm across)
            if ((leftWrist.y < leftShoulder.y && rightWrist.x < leftShoulder.x) ||
                (rightWrist.y < rightShoulder.y && leftWrist.x > rightShoulder.x)) {
                return "dab";
            }
            
            // HANDS ON HIPS
            if (leftHip && rightHip) {
                let leftHandOnHip = dist(leftWrist.x, leftWrist.y, leftHip.x, leftHip.y) < 100;
                let rightHandOnHip = dist(rightWrist.x, rightWrist.y, rightHip.x, rightHip.y) < 100;
                
                if (leftHandOnHip && rightHandOnHip) {
                    return "hands_on_hips";
                }
            }
            
            // ARMS BEHIND HEAD (both wrists near head level, elbows out)
            if (leftElbow && rightElbow && nose) {
                if (leftWrist.y < nose.y && rightWrist.y < nose.y && 
                    leftElbow.y < leftWrist.y && rightElbow.y < rightWrist.y &&
                    Math.abs(leftWrist.x - nose.x) < 150 && Math.abs(rightWrist.x - nose.x) < 150) {
                    return "arms_behind_head";
                }
            }
            
            return "default";
        }
        
        function scalePositionToCanvas(x, y) {
            // Scale pose coordinates from video resolution to canvas size
            let videoAspect = video.width / video.height;
            let canvasAspect = width / height;
            let scaleX, scaleY, offsetX, offsetY;
            
            if (canvasAspect > videoAspect) {
                scaleX = width / video.width;
                scaleY = scaleX;
                offsetX = 0;
                offsetY = (height - video.height * scaleY) / 2;
            } else {
                scaleY = height / video.height;
                scaleX = scaleY;
                offsetX = (width - video.width * scaleX) / 2;
                offsetY = 0;
            }
            
            return {
                x: x * scaleX + offsetX,
                y: y * scaleY + offsetY
            };
        }
        
        function drawKeypoints(pose) {
            for (let j = 0; j < pose.keypoints.length; j++) {
                let keypoint = pose.keypoints[j];
                if (keypoint.score > 0.2) {
                    let pos = scalePositionToCanvas(keypoint.position.x, keypoint.position.y);
                    fill(0, 255, 0, 150);
                    noStroke();
                    // Mirror the x coordinate
                    ellipse(width - pos.x, pos.y, 8, 8);
                }
            }
        }
        
        function drawSkeleton(pose) {
            let skeleton = [
                ["nose", "leftEye"],
                ["leftEye", "leftEar"],
                ["nose", "rightEye"],
                ["rightEye", "rightEar"],
                ["nose", "leftShoulder"],
                ["nose", "rightShoulder"],
                ["leftShoulder", "leftElbow"],
                ["leftElbow", "leftWrist"],
                ["rightShoulder", "rightElbow"],
                ["rightElbow", "rightWrist"],
                ["leftShoulder", "rightShoulder"],
                ["leftShoulder", "leftHip"],
                ["rightShoulder", "rightHip"],
                ["leftHip", "rightHip"],
                ["leftHip", "leftKnee"],
                ["leftKnee", "leftAnkle"],
                ["rightHip", "rightKnee"],
                ["rightKnee", "rightAnkle"]
            ];
            
            stroke(0, 255, 255, 120);
            strokeWeight(2);
            
            for (let j = 0; j < skeleton.length; j++) {
                let partA = pose[skeleton[j][0]];
                let partB = pose[skeleton[j][1]];
                
                if (partA && partB) {
                    let posA = scalePositionToCanvas(partA.x, partA.y);
                    let posB = scalePositionToCanvas(partB.x, partB.y);
                    // Mirror the x coordinates
                    line(width - posA.x, posA.y, width - posB.x, posB.y);
                }
            }
        }
        
        function displayMeme(memeType) {
            let meme = memes[memeType];
            
            // Semi-transparent overlay
            fill(0, 0, 0, 100);
            noStroke();
            rect(0, height - 120, width, 120);
            
            // Meme text with Impact font and black outline
            textAlign(CENTER);
            textFont('Impact');
            
            // Emoji
            textSize(32);
            fill(255, 255, 255);
            stroke(0);
            strokeWeight(4);
            text(meme.emoji, width / 2, height - 80);
            
            // Text
            textSize(24);
            fill(255, 255, 255);
            stroke(0);
            strokeWeight(3);
            text(meme.text.toUpperCase(), width / 2, height - 40);
            
            // Add sparkle effect for special poses
            if (memeType !== "default") {
                drawSparkles();
            }
        }
        
        function drawSparkles() {
            for (let i = 0; i < 3; i++) {
                let x = random(width);
                let y = random(height);
                let size = random(20, 40);
                
                fill(255, 255, 255, random(100, 200));
                noStroke();
                textSize(size);
                text("‚ú®", x, y);
            }
        }
        
        function updateInfoPanel(memeType) {
            let meme = memes[memeType];
            document.getElementById('meme-name').textContent = meme.name;
        }
        
        function loadPosesFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Load memes
                    if (data.memes) {
                        memes = { ...memes, ...data.memes };
                    }
                    
                    // Load custom pose detection
                    if (data.poseDetection) {
                        customPoseDetection = data.poseDetection;
                    }
                    
                    console.log('Loaded poses:', Object.keys(memes));
                    alert(`Successfully loaded ${Object.keys(data.memes || {}).length} custom poses!`);
                } catch (error) {
                    alert('Error loading JSON file: ' + error.message);
                    console.error(error);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }
        
        // Automatically load poses.json on page load
        async function loadDefaultPoses() {
            try {
                const response = await fetch('poses.json');
                if (!response.ok) {
                    console.warn('poses.json not found, using built-in poses');
                    return;
                }
                
                const data = await response.json();
                
                // Load memes
                if (data.memes) {
                    memes = { ...memes, ...data.memes };
                }
                
                // Load custom pose detection
                if (data.poseDetection) {
                    customPoseDetection = data.poseDetection;
                }
                
                console.log('Automatically loaded poses from poses.json:', Object.keys(data.memes || {}));
            } catch (error) {
                console.warn('Could not load poses.json:', error.message);
            }
        }
        
        // Load poses when page loads
        loadDefaultPoses();
        
        // ========== GAMIFICATION FUNCTIONS ==========
        
        function updateScoreDisplay() {
            document.getElementById('score').textContent = gameScore;
            document.getElementById('combo').textContent = comboMultiplier;
            document.getElementById('pose-count').textContent = poseCounter;
        }
        
        function checkAchievements() {
            achievements.forEach(ach => {
                if (!ach.unlocked && ach.check()) {
                    ach.unlocked = true;
                    showAchievement(ach);
                    saveAchievements();
                }
            });
        }
        
        function showAchievement(achievement) {
            const popup = document.getElementById('achievement-popup');
            const text = document.getElementById('achievement-text');
            text.textContent = `${achievement.name}: ${achievement.desc}`;
            popup.classList.add('show');
            
            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
        }
        
        function saveAchievements() {
            const unlockedIds = achievements.filter(a => a.unlocked).map(a => a.id);
            localStorage.setItem('achievements', JSON.stringify(unlockedIds));
        }
        
        // ========== MODAL FUNCTIONS ==========
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }
        
        function openLeaderboard() {
            const modal = document.getElementById('leaderboard-modal');
            const list = document.getElementById('leaderboard-list');
            
            // Add current session to leaderboard if score > 0
            if (gameScore > 0) {
                const sessionData = {
                    score: gameScore,
                    poses: poseCounter,
                    combo: comboMultiplier,
                    time: Date.now(),
                    uniquePoses: uniquePosesHit.size
                };
                
                leaderboard.push(sessionData);
                leaderboard.sort((a, b) => b.score - a.score);
                leaderboard = leaderboard.slice(0, 10); // Keep top 10
                localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
            }
            
            // Display leaderboard
            list.innerHTML = '';
            if (leaderboard.length === 0) {
                list.innerHTML = '<p style="text-align:center; color:#888;">No scores yet. Start posing!</p>';
            } else {
                leaderboard.forEach((entry, index) => {
                    const date = new Date(entry.time).toLocaleDateString();
                    const div = document.createElement('div');
                    div.className = 'leaderboard-entry';
                    div.innerHTML = `
                        <div>
                            <strong>#${index + 1}</strong> - ${entry.score} points
                            <br><small>${entry.poses} poses, ${entry.combo}x max combo, ${entry.uniquePoses} unique</small>
                        </div>
                        <div style="text-align:right;">
                            <small>${date}</small>
                        </div>
                    `;
                    list.appendChild(div);
                });
            }
            
            modal.classList.add('show');
        }
        
        function openAchievements() {
            const modal = document.getElementById('achievements-modal');
            const list = document.getElementById('achievements-list');
            
            list.innerHTML = '';
            achievements.forEach(ach => {
                const div = document.createElement('div');
                div.className = 'achievement-item' + (ach.unlocked ? ' unlocked' : '');
                div.innerHTML = `
                    <div>
                        ${ach.unlocked ? 'üèÜ' : 'üîí'} <strong>${ach.name}</strong>
                        <br><small>${ach.desc}</small>
                    </div>
                    <div>
                        ${ach.unlocked ? '‚úì Unlocked' : 'Locked'}
                    </div>
                `;
                list.appendChild(div);
            });
            
            modal.classList.add('show');
        }
        
        function openGallery() {
            const modal = document.getElementById('gallery-modal');
            const grid = document.getElementById('gallery-grid');
            
            grid.innerHTML = '';
            if (photoGallery.length === 0) {
                grid.innerHTML = '<p style="text-align:center; color:#888; grid-column: 1/-1;">No photos yet. Strike a pose!</p>';
            } else {
                photoGallery.reverse().forEach((photo, index) => {
                    const div = document.createElement('div');
                    div.className = 'gallery-item';
                    const date = new Date(photo.time).toLocaleString();
                    div.innerHTML = `
                        <img src="${photo.data}" alt="Pose ${photo.pose}">
                        <div class="gallery-item-time">${photo.pose} - ${date}</div>
                    `;
                    div.onclick = () => {
                        const win = window.open('');
                        win.document.write(`<img src="${photo.data}" style="max-width:100%; max-height:100vh;">`);
                    };
                    grid.appendChild(div);
                });
                photoGallery.reverse(); // Restore order
            }
            
            modal.classList.add('show');
        }
        
        function clearGallery() {
            if (confirm('Delete all photos? This cannot be undone.')) {
                photoGallery = [];
                localStorage.setItem('photoGallery', JSON.stringify(photoGallery));
                openGallery(); // Refresh
            }
        }
        
        function downloadAllPhotos() {
            if (photoGallery.length === 0) {
                alert('No photos to download!');
                return;
            }
            
            photoGallery.forEach((photo, index) => {
                const link = document.createElement('a');
                link.download = `pose_${photo.pose}_${index + 1}.png`;
                link.href = photo.data;
                link.click();
            });
        }
        
        function openChallenges() {
            const modal = document.getElementById('challenges-modal');
            const list = document.getElementById('challenges-list');
            
            // Show timer mode section if active
            if (timerMode) {
                document.getElementById('timer-mode-section').style.display = 'block';
            } else {
                document.getElementById('timer-mode-section').style.display = 'none';
                
                // Daily challenges
                list.innerHTML = `
                    <div class="challenge-box">
                        <h3>üéØ Daily Challenge</h3>
                        <p>Hit 20 different poses in one session</p>
                        <p>Progress: ${uniquePosesHit.size}/20</p>
                    </div>
                    <div class="challenge-box">
                        <h3>‚ö° Speed Challenge</h3>
                        <p>Reach 10x combo multiplier</p>
                        <p>Progress: ${comboMultiplier}/10</p>
                    </div>
                    <div class="challenge-box">
                        <h3>üíØ Century Challenge</h3>
                        <p>Score 500 points in one session</p>
                        <p>Progress: ${gameScore}/500</p>
                    </div>
                `;
            }
            
            modal.classList.add('show');
        }
        
        // ========== TIMER MODE FUNCTIONS ==========
        
        function toggleTimerMode() {
            if (!timerMode) {
                // Start timer mode
                timerMode = true;
                timerStartTime = Date.now();
                timerPosesRemaining = 10;
                uniquePosesHit.clear(); // Reset unique poses for this challenge
                
                // Update UI
                document.getElementById('timer-target').textContent = timerPosesRemaining;
                document.getElementById('timer-remaining').textContent = timerPosesRemaining;
                
                // Start timer display
                timerInterval = setInterval(() => {
                    const elapsed = (Date.now() - timerStartTime) / 1000;
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = Math.floor(elapsed % 60);
                    document.getElementById('timer-display').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }, 100);
                
                openChallenges(); // Show challenge modal
                alert('Timer Challenge Started! Hit 10 different poses as fast as possible!');
            } else {
                stopTimerMode();
            }
        }
        
        function updateTimerMode(poseName) {
            if (!timerMode) return;
            
            // Check if this is a new pose
            if (!uniquePosesHit.has(poseName)) {
                timerPosesRemaining--;
                document.getElementById('timer-remaining').textContent = timerPosesRemaining;
                
                // Check if challenge completed
                if (timerPosesRemaining <= 0) {
                    const elapsed = (Date.now() - timerStartTime) / 1000;
                    clearInterval(timerInterval);
                    timerMode = false;
                    
                    alert(`Challenge Complete! Time: ${elapsed.toFixed(1)} seconds`);
                    
                    // Check for speedster achievement
                    if (elapsed < 30) {
                        let speedsterAch = achievements.find(a => a.id === 'speedster');
                        if (speedsterAch && !speedsterAch.unlocked) {
                            speedsterAch.unlocked = true;
                            showAchievement(speedsterAch);
                            saveAchievements();
                        }
                    }
                    
                    closeModal('challenges-modal');
                }
            }
        }
        
        function stopTimerMode() {
            if (timerMode) {
                clearInterval(timerInterval);
                timerMode = false;
                closeModal('challenges-modal');
            }
        }
        
        // ========== SCREENSHOT FUNCTIONS ==========
        
        function takeScreenshot(autoCapture = false) {
            // Capture the canvas
            const canvas = document.querySelector('canvas');
            if (!canvas) return;
            
            canvas.toBlob(blob => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const photo = {
                        data: reader.result,
                        pose: confirmedMeme,
                        time: Date.now()
                    };
                    
                    photoGallery.push(photo);
                    
                    // Store in localStorage (with size limit check)
                    try {
                        localStorage.setItem('photoGallery', JSON.stringify(photoGallery));
                    } catch (e) {
                        console.warn('Storage full, removing old photos');
                        photoGallery.shift(); // Remove oldest
                        localStorage.setItem('photoGallery', JSON.stringify(photoGallery));
                    }
                    
                    if (!autoCapture) {
                        // Manual screenshot - show notification and download
                        alert('Screenshot saved to gallery!');
                        const link = document.createElement('a');
                        link.download = `pose_${confirmedMeme}_${Date.now()}.png`;
                        link.href = reader.result;
                        link.click();
                    }
                };
                reader.readAsDataURL(blob);
            });
        }
        
        // ========== VIDEO RECORDING FUNCTIONS ==========
        
        function toggleRecording() {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        }
        
        function startRecording() {
            const canvas = document.querySelector('canvas');
            if (!canvas) return;
            
            const stream = canvas.captureStream(30); // 30 FPS
            recordedChunks = [];
            
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9'
            });
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `pose_recording_${Date.now()}.webm`;
                link.href = url;
                link.click();
                
                alert('Recording saved!');
            };
            
            mediaRecorder.start();
            isRecording = true;
            
            // Update button
            document.querySelector('[onclick="toggleRecording()"]').textContent = '‚èπÔ∏è';
            document.querySelector('[onclick="toggleRecording()"]').style.background = 'rgba(255, 107, 107, 0.9)';
        }
        
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                isRecording = false;
                
                // Reset button
                document.querySelector('[onclick="toggleRecording()"]').textContent = 'üé•';
                document.querySelector('[onclick="toggleRecording()"]').style.background = 'rgba(102, 126, 234, 0.9)';
            }
        }
        
        // Initialize score display
        updateScoreDisplay();
    </script>
</body>
</html>